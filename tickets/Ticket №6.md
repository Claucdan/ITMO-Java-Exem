# Сборка мусора на поколениях. Устройство кучи. Принцип работы.
## Generational Collection
### Идея
Алгоритм основанный на «слабой гипотезы о поколениях», состоящей из двух закономерностей:
1. Большинство объектов живут либо очень долго, либо очень недолго, а также долгоживущих объектов очень мало. 
2. Связей между старыми и новыми объектами очень мало.

В этом алгоритме память условно делится на две области:
- young generation, состоящий из трех разделов: 
	- Eden,
	- S0 (survivor space 0)
	- S1 (survivor space 1)
- old generation (Tenured).
### Алгоритм
Исходя из разделения на области памяти, есть разделения и на сборки мусора: 
- minor, собирает мусор в Eden, S0 и S1;
- major, собирает мусор в Tenured;
- full, собирает мусор везде.

А сам алгоритм выглядит так:
1. Объекты создается в Eden. 
2. При запуске minor - сборки все живое из Eden перемещается в S0. 
3. При запуске следующей minor - сборки все живое из Eden и S0 перемещается в S1, и, грубо говоря, S1 и S0 меняются местами. 
4. После нескольких пережитых minor - сборок все живое из S0 перемещается в Tenured.
## Устройство Кучи
### Память
В Java память приложения можно разделить на стек, (Stack memory), и кучу, (Heap memory). В куче хранятся объекты. В стеке хранятся ссылки на объекты из кучи и переменные примитивных типов данных.
### Stack memory
- работает по принципу стека, (удивительно, но факт);
- хранит ссылки на объекты;
- хранит примитивы;
- переменные имеют область видимости, (невозможно получить доступ к переменным, объявленным в методе А, из метода B);
- для каждого потока выполнения отдельная stack memory
### Heap memory
- здесь фактически хранятся объекты, ссылки на которые лежат в stack memory;
- одна для всех потоков
### String pool
- отдельная область Heap Memory, в которой хранятся строки; 
- хранит все строки, созданные во время работы приложения, следовательно при повторном создании строки, значение которой уже существовало, новый объект не создастся, мы просто получим еще одну ссылку на уже существующий объект
> Вообще не всегда, строка может быть удалена сборщиком мусора.
---
```java
String s1 = "hello";
String s2 = "hello";
```
В данном примере один «hello» создастся в String pool, а s1 и s2, оба будут ссылаться на один этот «hello».
```java
String s3 = new String("hello");
String s4 = new String("hello");
```
В данном примере два объекта со значением «hello» создадутся в Heap memory. И s3 будет ссылаться на один из объектов, а s4 на второй.
### Числовые пулы
Также существуют числовые пулы для: Byte, Short, Integer, Long, Character. 
Но в отличие от String pool, это не отдельный раздел памяти в Heap, а механизм кэширования. 
При старте JVM создается массив объектов соответствующего типа определенного диапазона.

|                    | *Диапазон*          | *Обращение*                 | *Расширяемость*                |
| ------------------ | ------------------- | --------------------------- | ------------------------------ |
| **Byte pool**      | `-128 ... 127`      | `Byte b = 3;`               | Нет                            |
|                    |                     | `Byte b = valueOf(5);`      |                                |
| **Short pool**     | `-128 ... 127`      | `Short s = 3;`              | Нет                            |
|                    |                     | `Short s = valueOf(5);`     |                                |
| **Integer pool**   | `-128 ... 127`      | `Integer i = 3;`            | Нет                            |
|                    |                     | `Integer i = valueOf(5);`   |                                |
| **Long pool**      | `-128 ... 127`      | `Long l = 3;`               | Да, `(-XX:AutoBoxCacheMax=n)*` |
|                    |                     | `Long l = valueOf(5);`      |                                |
| **Character pool** | `0 ... 127` (ASCII) | `Character c = 3;`          | Нет                            |
|                    |                     | `Character c = valueOf(5);` |                                |

