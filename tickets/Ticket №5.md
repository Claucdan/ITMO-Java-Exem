# Автоматическое управление памятью. Алгоритмы отчистки.
## Взаимодействие с памятью
### Unmanaged PL
Сам объект создал, попользовался им, удалил из памяти, когда необходимость в нем пропала. То есть у нас полностью ручное управление, и все зависит исключительно от места, из которого растут руки программиста.
### Managed PL
Можно очень условно обобщить названия механизмов управления памятью в различных ЯП до **Garbage collector**. У GC всего две задачи: найти мусор, отчистить мусор. Мусор - это объект в памяти, к которому из программного кода больше невозможно получить доступ.

> **Garbage collector** - процесс, освобождающий память приложения путем уничтожения неиспользуемых объектов.

### Garbage collector
Существует несколько реализаций GC, работающих по различным алгоритмам, каждый из которых по своему решает проблему отслеживания и уничтожения уже ненужных объектов. Какие-то реализации лучше работают на больших размерах heap-а, какие-то лучше работают на средних размерах и меньше.

При этом по спецификации нет никаких правил для реализации GC, кроме сбора объектов, которые гарантировано более не могут быть использованы.
### Поиск мусора
Нахождение мусора на самом деле не тривиальная задача. 
Существуют 2 подхода для поиска мусора:
#### Reference counting
##### Информация
Из названия понятно, что подход основан на подсчете ссылок. 
Каждый объект имеет счетчик, который хранит информацию, сколько ссылок указывают на этот объект. 
При создании ссылки на объект, счетчик увеличивается. Когда ссылка уничтожается, счетчик уменьшается. 
Если значение счетчика равно нулю, объект считается мусором и память, которую он занимает, можно отчищать
##### Пример
```java
public void doSomething() {
 Integer i = 500;
 Integer j = i;
 Integer sum = i + j;
 j = 400;
}
```
Рассмотрим данный подход на примере объекта Integer(500). 
1. На 2 строке объявляется ссылка i на Integer(500), а его счетчик равен 1. 
2. На 3 строке объявляется ссылка j на тот же объект, теперь его счетчик равен 2.
3. На 5 строке ссылка j переписывается на объект Integer(400). А счетчик Integer(500) уменьшается и равен 1. 
4. По выходу из метода локальные ссылки i и j уничтожаются, так как они живут только внутри метода. 
5. Счетчик на объект Integer(500) уменьшается и равен 0. Теперь Integer(500) - мусор, и GC может его удалить.
##### Плюсы
- простота реализации; 
- отсутствуют длительные паузы работы приложения для поиска мусора.
##### Минусы
- не обнаружит циклические ссылки; 
- требуется дополнительное время на изменение счетчика; 
- требуется дополнительная память на счетчик; 
- проблемы с многопоточностью.
#### Tracing
##### Идея
Если до объекта можно дойти от «корня», то это живой объект. До чего дойти не можем - мусор.
##### GC Root
Этот корень называется **GC Root**. **GC Root** может быть:
- параметры методов;
- локальные переменные;
- потоки Java;
- статические переменные;
- ссылки из JNI.
```java
Person p = new Person();
p.setName("Oleg");
p.setCar(new Car("Lada Niva 4x4"));
p.getCar().setEngine(new Engin());
```
В данной ситуации Person - GC root. Допустим, Person живой объект, и следовательно Name, Car, Engine тоже живые объекты, т.к. мы можем добраться до них от Person.
```java
public class Main{
	public static void main(String[] args) {
		System.out.println("Hello, World!!!");
	}
}
```
Даже в таком простом коде  у нас есть следующие GC Root: 
- поток, выполняющий метод main; 
- параметры метода main. 
Также GC Root могли быть локальные переменные метода main и статические переменные класса Main.
## Очистка мусора
Очистка мусора процесс очень понятный, но сложный. И в этот раз из-за сложности в нашем мире есть несколько алгоритмов, выполняющих задачу очистки. 
Существуют 4 подхода для сборки мусора: 
- **Copying Collector**; 
- **Mark-and-Sweep**;
- **Mark-and-Sweep Compact**; 
- **Generational Collection**.
### Stop the world
##### Определение
полная остановка выполнения приложения для запуска цикла сборки мусора. 
##### Преимущества: 
- проще определять достижимость объектов, так как граф объектов заморожен; 
- проще перемещать объекты в heap memory, так как в момент остановки мы можем перевести память в некорректное состояние. 

> Если пауза критична, то одну большую паузу превращают в много маленьких, нагружая этим процессор.
### Copying Collector
##### Идея
Память условно делится на две области: **from-space** и **to-space**. 
##### Этапы выполнения
1. Все объекты создаются в **from-space**, и **from-space** полностью заполняется. 
2. **Stop the world**. 
3. Все живые объекты перемещаются **в to-space**. 
4. Все мертвые объекты очищаются. 
5. **From-space** и **to-space** меняются местами.
##### Преимущества:
- Быстрая очистка (просто копирование живых объектов)
- Нет фрагментации памяти
- Простота реализации
##### Недостатки:
- Требует вдвое больше памяти
- Неэффективен при большом количестве долгоживущих объектов
### Mark-and-Sweep
##### Этапы выполнения
1. Все объекты создаются в памяти и она заполняется. 
2. **Stop the world**. 
3. Помечаем все живые объекты, (**Mark**).
4. Чистим все мертвые объекты, (**Sweep**). 
5. Снимаем все пометки с живых объектов
##### Преимущества:
- Не требует дополнительной памяти
- Работает с существующей структурой памяти
##### Недостатки:
- Вызывает фрагментацию памяти
- Stop-the-World паузы (приложение останавливается)
- Не перемещает объекты (нет компактификации)
### Mark-and-Sweep Compact
##### Этапы выполнения
1. Все объекты создаются в памяти и она заполняется. 
2. Помечаем все мертвые объекты, (**Mark**). 
3. **Stop the world**. 
4. Чистим все мертвые объекты, (**Sweep**). 
5. Дефрагментируем память, (**Сompact**).
##### Преимущества:
- Устраняет фрагментацию
- Улучшает локализацию данных
##### Недостатки:
- Дополнительные накладные расходы на компактификацию
- Более длительные Stop-the-World паузы
### Generational Collection
##### Идея
Алгоритм основанный на «слабой гипотезы о поколениях», состоящей из двух закономерностей:
1. Большинство объектов живут либо очень долго, либо очень недолго, а также долгоживущих объектов очень мало. 
2. Связей между старыми и новыми объектами очень мало.

В этом алгоритме память условно делится на две области:
- young generation, состоящий из трех разделов: 
	- Eden,
	- S0 (survivor space 0)
	- S1 (survivor space 1)
- old generation (Tenured).
##### Алгоритм
Исходя из разделения на области памяти, есть разделения и на сборки мусора: 
- minor, собирает мусор в Eden, S0 и S1;
- major, собирает мусор в Tenured;
- full, собирает мусор везде.

А сам алгоритм выглядит так:
1. Объекты создается в Eden. 
2. При запуске minor - сборки все живое из Eden перемещается в S0. 
3. При запуске следующей minor - сборки все живое из Eden и S0 перемещается в S1, и, грубо говоря, S1 и S0 меняются местами. 
4. После нескольких пережитых minor - сборок все живое из S0 перемещается в Tenured.
### Сравнение алгоритмов
|                                        | *Copying Collector*             | *Mark-and-Sweep*             | *Mark-and-Sweep Compact*         | *Generational Collection* |
| -------------------------------------- | ------------------------------- | ---------------------------- | -------------------------------- | ------------------------- |
| **Использование памяти**               | Половина                        | Вся                          | Вся                              | Вся                       |
| **Фрагментация**                       | Нет                             | Есть                         | Нет                              | Или есть, или нет         |
| **Производительность**                 | Зависит от числа живых объектов | Зависит от размера всей кучи | Mark and Sweep + компактификация | Высокая                   |
| **Подходит для маложивущих объектов**  | Хорошо                          | Плохо                        | Плохо                            | Отлично                   |
| **Подходит для долгоживущих объектов** | Плохо                           | Хорошо                       | Хорошо                           | Отлично                   |
| **Остановка приложения**               | Полная                          | Полная                       | Полная                           | Частичная                 |
| **Пауза в работе**                     | Быстрая, если мало живых        | Быстрая на маленьких кучах   | Долгая                           | Минимальная               |
| **Сложность реализации**               | Простой                         | Сложнее                      | Еще Сложнее                      | Самый сложный             |
## Реализации GC
### Serial GC
Однопоточный сборщик. Работает на основе поколений, (в old generation использует Mark and Sweep Compact). Подходит для однопоточных приложений с малой нагрузкой. Простой и экономичный, но медленный.
### Parallel GC
Тоже самое, что Serial GC, но работает многопоточно. Используется по умолчанию.
### CMS GC
Удален в Java 17, (deprecated в Java 14). Работает по принципу Mark and Sweep, для сокращения длительности пауз, путем увеличения их количества.
### G1 GC
Замена СMS GC. Работает на основе поколений, но делит их на регионы, (от 1 Мб до 32 Мб). По поколениям работает аналогично Serial GC, но для каждой сборки мусора выбирает самые «грязные» регионы.
### ZGC
«Промышленный» GC. Работает с кучами до 16 Тб. Отличная производительность на больших кучах. Требует больших ресурсов СPU. Существует с Java 11, стабильный с Java 16.
### Shenandoah GC
«Промышленный» GC. Работает с кучами до 2 Тб. Отличная производительность на маленьких кучах. Требует больших ресурсов СPU. Существует с Java 12, стабильный с Java 15.
