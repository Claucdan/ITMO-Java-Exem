# Особенности реализации CDI в Spring. Внедрение зависимостей. Инверсия контроля.
## Spring
### Что это?
Spring задумывался и был реализован, как более удобная Java EE. 
Плюсы перед Enterprise Edition:
- spring совместим с Java EE (но не наоборот);
- разделен на проекты, (MVC, Data и пр.). Можно подключить только нужное;
- активно поддерживается сообществом.
### Зачем оно нам надо?
![Pasted image 20250610142551.png](../photos/Pasted%20image%2020250610142551.png)
Исключая возможности, которые предоставляют «узкоспециализированные» проекты Spring, (взаимодействие с БД, WEB, security и т.д.), ядро фреймворка предоставляет нам: инверсию и внедрение зависимостей, и конфигурацию приложения.
### Inversion of control
**Инверсия управления** (**Inversion of control**) — это идея разработки ПО, при которой управление объектами или частями программы передается в контейнер или платформу. 

**IoC** дает несколько преимуществ:
•разделение выполнения задачи и ее реализации;
•упрощение переключения между различными реализациями;
•большая модульность программы;
•большее упрощение тестирования программы за счет изоляции компонента или имитации его зависимостей, а также разрешения компонентам взаимодействовать через контракты.

В **Spring** контейнером для **IoC** выступает интерфейс **ApplicationContext**. Он отвечает за создание, настройку и сборку объектов, которые в **Spring** называются **Bean** – компонентами. Также **Context** отвечает за управление жизненными циклами бинов.

> **Spring Bean** – это обычный объект *Java*, (*POJO*), в который закладывается дополнительная метаинформация, с помощью которой **ApplicationContext** распознает в нем сущность, которой он должен управлять.

### Реализация IoC
1. Поиск зависимостей – вызывающий объект запрашивает у контейнера экземпляр класса с определённым именем или типом
![Pasted image 20250610142919.png](../photos/Pasted%20image%2020250610142919.png)
2. Внедрение зависимостей – способ, в котором контейнер передает экземпляры объектов по их имени другим объектам
![Pasted image 20250610142932.png](../photos/Pasted%20image%2020250610142932.png)

### Внедрение зависимостей
Внедрение зависимостей в Spring реализуется несколькими способами:
- Внедрение через конструктор
```java
// 1 Вариант (Ручками)
@Component
public class Car{

	private Engine engine;

	@Authowired
	public Car(Engine engine) {
		this.engine = engine
	}
}

// 2 Вариант (Lombok)
@Component
@RequiredArgsConstructor
public class Car{

	private final Engine engine;
}
```
- Внедрение через set-метод
```java
@Component
public class Car{

	private Engine engine;

	@Authowired
	public setEngoneCar(Engine engine) {
		this.engine = engine
	}
}
```
- Внедрение через свойства
```java
@Component
public class Car{

	@Authowired
	private Engine engine;
}
```
### Этапы запуска Spring
#### Парсинг конфигурации и создание BeanDefinition всех бинов, которые нам понадобятся.
У Spring есть 4 способа конфигурации:
##### XML конфигурация  
**Конструктор**: ClassPathXmlApplicationContext(“context.xml”)
##### Groovy конфигурация  
**Конструктор**: GenericGroovyApplicationContext(“context.groovy”)
##### Конфигурация через аннотации с указанием пакета для сканирования
**Конструктор**: AnnotationConfigApplicationContext(“package.name”)
**Этапы:**
	1. ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component или ее наследниками. 
	2. Найденные классы парсятся и для них создаются BeanDefinition.
	3. Каждый BeanDefinition вместе со своим именем помещается в BeanDefinitionMap.
##### Java Config 
**Конструктор**: AnnotationConfigApplicationContext(JavaConfig.class)
**Этапы:**
	1. Первый этап — это регистрация всех @Configuration для дальнейшего парсинга.
	2. Второй этап — ПАРСИНГ И СОЗДАНИЕ BeanDefinition, (это регистрация специального BeanFactoryPostProcessor, а именно BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсит JavaConfig и создает BeanDefinition).
	3. Каждый BeanDefinition вместе со своим именем помещается в BeanDefinitionMap. 
##### Сравнение

| Характеристика                                | XML | Аннотации | Java Config |
| --------------------------------------------- | --- | --------- | ----------- |
| Отсутствие Spring в коде                      | +   | -         | +           |
| Изменение конфигурации требует перекомпиляции | +   | -         | -           |
| Типобезопасность                              | -   | +         | +           |
| Полная поддержка IDE                          | -   | -         | +           |
| Декларация бинов из сторонних библиотек       | +   | -         | +           |
| Возможность писать логику в конфигурации      | -   | -         | +           |
##### BeanDefinition
- Имя класса с указанием пакета.
- Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере (scope, обратные вызовы жизненного цикла и т.д.).
- Ссылки на другие bean-компоненты, которые необходимы для его работы. Эти ссылки также называются зависимостями.
- Другие параметры конфигурации для установки во вновь созданном объекте, например, ограничение размера пула или количество соединений, используемых в бине, который управляет пулом соединений.
#### Настройка созданных BeanDefinition
В Spring мы можем повлиять на то, какими будут наши бины еще до того, как они создадутся.
##### BeanFactoryPostProcessor
Благодаря интерфейсу BeanFactoryPostProcessor мы можем получить доступ к созданным BeanDefinition и можем их изменять.

Метод postProcessBeanFactory принимает параметром ConfigurableListableBeanFactory. Данная фабрика содержит много полезных методов, в том числе getBeanDefinitionNames, через который мы можем получить все BeanDefinitionNames, а уже потом по конкретному имени получить BeanDefinition для дальнейшей обработки метаданных.
#### Создание кастомных FactoryBean (рудимент)
Когда-то Spring конфигурировался только через XML и разработчикам очень хотелось добавлять какое-либо поведение при создании бина.
Из этого запроса появился интерфейс FactoryBean.
#### BeanFactory создает экземпляры бинов, при необходимости делегируя создание бина FactoryBean
Созданием экземпляров бинов занимается BeanFactory, при необходимости делегируя самописным FactoryBean.

Экземпляры бинов создаются на основе BeanDefinition.

После создания бина, (неважно бобовой фабрикой или самописной фабрикой бобов), они почти попадают в Map<BeanName, Bean> великого и ужасного ApplicationContext.
#### Настройка созданных бинов
Разработчик может модернизировать бины до того, как они попадут в мапу ApplicationContext, то есть чуть-чуть донастроить их.

Аналогично BeanFactoryPostProcessor, который дает разработчику доступ к созданным BeanDefinition, BeanPostProcessor дает разработчику доступ к созданным бинам.

Разница между методами в порядке их вызова, первый вызывается до инициализации бина, второй после.

−Оба метода обязаны вернуть в ответ бин, потому что через BeanPostProcessor проходят абсолютно все бины, даже, если с ними ничего не произойдет внутри, вы все равно получите на выходе все бины, в которых по ссылкам лежит null – значения.

−BeanPostProcessor прекарсно подходит для реализации прокси, (имейте ввиду, что прокси принято делать в методе postProcessAfterInitialization, то есть после инициализации бина).
### Схема создания бинов
![Pasted image 20250610144811.png](../photos/Pasted%20image%2020250610144811.png)
### Spring Been Scopes
- **Singleton** – область видимости по умолчанию, один бин на весь runtime.
- **Prototype** – возвращает новый экземпляр каждый раз, когда запрашивается из ApplicationContext.
- **Request** – на каждый HTTP – запрос создается новый экземпляр.
- **Session** – на каждую HTTP – сессию создается новый экземпляр.
- **Application** – один на ServletContext.
- **Websocket** – один на каждый WebSocket.