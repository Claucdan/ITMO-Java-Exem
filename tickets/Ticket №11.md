# Основные задачи решаемые с помощью Spring Boot. С помощью каких инструментов достигается результат?
## Spring Boot
### Зачем оно нам?
Дополнение к Spring, которое облегчает и ускоряет работу с ним. Сам Spring Boot представляет собой набор утилит, автоматизирующих настройки фреймворка.

Сам по себе Spring имеет достаточно большое количество зависимостей и множество сложных конфигураций, которые к тому же чаще всего описаны в XML, из-за чего у рядового разработчика могут возникнуть проблемы при знакомстве с фреймворком. Для упрощения этого процесса на помощь приходит Spring Boot — самый быстрый и популярный способ запуска Spring-проектов.
### Как было без Spring Boot
Каждый раз, создавая очередное корпоративное Java-приложение на основе Spring, вам необходимо повторять одни и те же рутинные шаги по его настройке:
1. В зависимости от типа создаваемого приложения (Spring MVC, Spring JDBC, Spring ORM и т. д.) импортировать необходимые Spring-модули
2. Импортировать библиотеку web-контейнеров (в случае web-приложений)
3. Импортировать необходимые сторонние библиотеки (например, Hibernate, Jackson), при этом вы должны искать версии, совместимые с указанной версией Spring
4. Конфигурировать компоненты DAO, такие, как: источники данных, управление транзакциями и т. д.
5. Определить класс, который загрузит все необходимые конфигурации
### Основные цели Spring Boot
- Обеспечить быстрый и широко доступный опыт начальной работы для любых разработок на Spring.
- Возможность кастомизировать стандартное поведение.
- Предоставлять ряд нефункциональных возможностей, которые являются общими для больших классов проектов (таких как встроенные серверы, безопасность, метрики, проверка работоспособности, тестирование и конфигурация).
- Уйти от старых подходов с XML-конфигурациями
### С помощью чего это получается?
Согласно [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot):
- ‘starter’ зависимости с облегчающие конфигурацию
- Автоматическая конфигурация различных библиотек
- Преднастроенный Application Server (Apache Tomcat)
- Готовые рецепты для широко используемых подходов (таких как метрики, внешняя конфигурация и т.д.)
### Starter packages
Всё удобство Spring Boot основано на использовании так называемых Starter, которые позволяют получить набор сконфигурированных бинов, готовых к использованию и доступных для конфигурации через properties-файлы.

Краеугольным камнем инфраструктуры Spring Boot являются AutoConfiguration-классы, которые Spring Boot находит при запуске приложения и использует для автоматического создания и конфигурирования бинов.

Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение. Это позволит получить универсальное решение для всех, связанных со Spring технологий, избавляя программиста от лишнего поиска примеров кода и загрузки из них требуемых дескрипторов зависимостей.

Например, если вы хотите начать использовать Spring Data JPA для доступа к базе данных, просто включите в свой проект зависимость spring-boot-starter-data-jpa и все будет готово (вам не придется искать совместимые драйверы баз данных и библиотеки Hibernate).

Также, если вы хотите создать Spring web-приложение, просто добавьте зависимость spring-boot-starter-web, которая подтянет в проект все библиотеки, необходимые для разработки Spring MVC-приложений, таких как spring-webmvc, jackson-json, validation-api и Tomcat.  

Другими словами, Spring Boot собирает все общие зависимости и определяет их в одном месте, что позволяет разработчикам просто использовать их, вместо того, чтобы изобретать колесо каждый раз, когда они создают новое приложение.
### Application Server
Apache Tomcat — это комплект серверных программ от Apache Software Foundation, предназначенный для тестирования, отладки и исполнения веб-приложений на основе Java. Его обычно называют контейнером сервлетов — дополнительных компонентов, которые расширяют функциональность веб-сервера и позволяют ему выполнять приложения на языке Java.

DispatcherServlet из Spring (с прошлой лекции) как раз крутится внутри этого самого Tomcat’a.
### AutoConfiguration
Второй превосходной возможностью Spring Boot является автоматическая конфигурация приложения.
После выбора подходящего starter-пакета, Spring Boot попытается автоматически настроить Spring-приложение на основе добавленных вами jar-зависимостей.
### Spring Initializr
Чтобы каждый раз не создавать с нуля Spring проект на Java и не искать последние версии зависимостей, можно воспользоваться сервисом [Spring Initializr](https://start.spring.io/), который предоставляет интерфейс для генерации заготовки проекта с добавлением стандартных зависимостей. Их можно конфигурировать в зависимости от ваших потребностей.

В качестве сборщика проекта выберем предпочитаемый, и Spring Initializr автоматически сгенерирует скрипт сборки.

В IntelliJ Idea от JetBrains на данный момент уже имеет интеграцию с этим генератором, можно создавать шаблон непосредственно из IDE.
### Spring Beans и внедрение зависимостей
Когда вы будете структурировать свой код, то вам понадобится добавлять аннотацию @ComponentScan или использовать аннотацию @SpringBootApplication, которая неявно содержит её. Все компоненты вашего приложения (аннотации @Component, @Service, @Repository, @Controller и другие) автоматически регистрируются как бины Spring.
### Dev tools
Инструментальные средства разработки автоматически деактивируются при выполнении полностью упакованного приложения. Если ваше приложение запускается через java -jar или через специальный загрузчик классов, то оно считаетсяProduction-сборкой.  
  
Вы можете управлять этой логикой работы при помощи системного свойства spring.devtools.restart.enabled. Однако нужно понимать что это нельзя делать в Production среде, где выполнение devtools представляет угрозу безопасности.
#### Автоматический перезапуск
Приложения, использующие spring-boot-devtools, автоматически перезапускаются при изменении файлов в classpath. Это может быть полезной функцией при работе в IDE, так как обеспечивает очень быструю обратную связь для внесения изменений в код. По умолчанию любая запись в classpath, указывающая на каталог, отслеживается на предмет изменений. Обратите внимание, что некоторые ресурсы, такие как статическое содержимое и шаблоны представлений, не требуют перезапуска приложения.

Данный подход в индустрии также известен как Hot Module Reload
#### Перезапуск и перезагрузка
Технология перезапуска, предусмотренная Spring Boot, работает при помощи двух загрузчиков классов. Классы, которые не изменяются (например, классы из сторонних jar-файлов), загружаются в основной загрузчик классов. Классы, которые активно разрабатываются, загружаются в перезапускающий загрузчик классов. Если приложение перезапускается, перезапускающий загрузчик классов единовременно используется, после чего создается новый. Такой подход означает, что перезапуск приложения обычно происходит гораздо быстрее, чем "холодный запуск", поскольку основной загрузчик классов уже доступен и заполнен.
### Цикл жизни Spring Application
В дополнение к обычным событиям Spring Framework, таким как ContextRefreshedEvent, на которое в основном и реагирует dev-tools для обеспечения горячей замены разрабатываемых Bean’ов, Spring посылает некоторые дополнительные события.

События приложения отправляются в следующем порядке по мере выполнения приложения:

1. Событие ApplicationStartingEvent отправляется в начале выполнения, но перед началом любой обработки, за исключением регистрации слушателей и инициализаторов.
2. Событие ApplicationEnvironmentPreparedEvent отправляется, когда Environment, которое будет использоваться в контексте, известно, но перед созданием контекста.
3. Событие ApplicationContextInitializedEvent отправляется, когда ApplicationContext подготовлен и вызваны ApplicationContextInitializers, но перед загрузкой определений бинов.
4. Событие ApplicationPreparedEvent отправляется непосредственно перед началом обновления, но после загрузки определений бинов.
5. Событие ApplicationStartedEvent отправляется после обновления контекста, но перед тем, как будут вызваны все средства выполнения приложения и командной строки.
6. Сразу после этого отправляется событие AvailabilityChangeEvent с LivenessState.CORRECT, чтобы обозначить, что приложение считается работающим.
7. Событие ApplicationReadyEvent отправляется после вызова любого средства выполнения приложений и командной строки.
8. Сразу после этого отправляется событие AvailabilityChangeEvent с ReadinessState.ACCEPTING_TRAFFIC, чтобы обозначить, что приложение готово к обработке запросов.
9. Событие ApplicationFailedEvent отправляется, если при запуске возникло исключение.

Приведенный выше список включает только события SpringApplicationEvent, которые привязаны к SpringApplication.