# Какие ключевые задачи решают брокеры сообщений? Перечислите известные вам модели обмена сообщениями и протоколы.
## Какие ключевые задачи решают брокеры сообщений?
### Асинхронная коммуникация
#### Проблема
Прямые HTTP/RPC-вызовы создают жесткую связь между сервисами.
#### Решение
- Отправитель и получатель работают независимо.
- Отправитель публикует сообщение в брокер, получатель обрабатывает его, когда готов
### Буферизация и нагрузка
#### Проблема
Пиковые нагрузки могут "положить" сервис.
#### Решение
- Брокер накапливает сообщения в очередях.
- Позволяет потребителям обрабатывать сообщения со своей скоростью.
### Гарантированная доставка
#### Проблема
Сбои сети или сервисов приводят к потере данных.  
#### Решение
- Подтверждения (acknowledgments):
    - Брокер удаляет сообщение только после подтверждения обработки.
- Сохранение на диск:
    - Сообщения не теряются при перезапуске брокера.
### Маршрутизация
#### Проблема
Нужно направлять сообщения разным получателям по условиям.
#### Решение
- **Exchange** в RabbitMQ:
    - Direct (по ключу), Topic (по маске), Fanout (всем).
- **Kafka Topics**:
    - Разделение по темам (например, `orders`, `payments`).
### Масштабируемость
#### Проблема
Вертикальное масштабирование (увеличение мощности сервера) ограничено.
#### Решение
- Горизонтальное масштабирование:
- Несколько потребителей одной очереди (конкурирующие потребители).
- Партиционирование в Kafka (параллельная обработка).
### Интеграция разнородных систем
#### Проблема 
Сервисы на разных языках/технологиях не могут общаться напрямую.  
#### Решение
- Брокер выступает универсальным посредником.
- Поддержка стандартных протоколов (AMQP, MQTT, STOMP).
### Обеспечение отказоустойчивости
#### Проблема 
Отказ одного сервиса не должен влиять на всю систему.  
#### Решение
- Повторная отправка сообщений при ошибках.
- Dead Letter Queue (DLQ) для проблемных сообщений.
## Модели обмена сообщениями и протоколы.
### ActiveMQ
#### Информация
ActiveMQ лучше всего описать, как классическую систему обмена сообщениями. Она была написана в 2004 году, восполняя потребность в брокере сообщений с открытым исходным кодом. В то время, если вы хотели использовать обмен сообщениями в своих приложениях, единственным выбором были дорогие коммерческие продукты.

ActiveMQ была разработана как реализация спецификации Java Message Service (JMS).
JMS же описывает абстракции для отправки и получения сообщений в асинхронном режиме по подписочной модели.

![[Pasted image 20250610185233.png]]
#### Почему JMS
1. *Чёткие разделения обязанностей*
	- **Брокер**: обязан доставлять и распределять сообщения.
	- **Клиент**: взаимодействует только с адресатом (очередью/топиком), не заботясь о внутренней логике брокера.
2. *Гибкость протокола*
	- JMS **не стандартизирует протокол связи** между клиентом и брокером, что позволило:
	    - ActiveMQ создать собственный эффективный протокол — **OpenWire**.
	    - Обеспечить совместимость с другими брокерами через адаптеры (например, STOMP, AMQP).
	- OpenWire стал основой для кросс-языковых клиентов (C++, .NET) в экосистеме ActiveMQ.
#### JMS API
##### Краткая сводка
API определяет набор программных интерфейсов, используемых клиентским кодом
ConnectionFactory -> Connection -> Session
MessageProducer / MessageConsumer
И непосредственно сам Message.
##### ConnectionFactory
Это интерфейс верхнего уровня, используемый для установления соединений с брокером. В типичном приложении обмена сообщениями существует единственный экземпляр (Singleton) этого интерфейса. В ActiveMQ — это ActiveMQConnectionFactory. На верхнем уровне эта конструкция сообщает местонахождение брокера сообщений, вместе с низкоуровневыми деталями того, как следует взаимодействовать с ним. Как следует из названия, ConnectionFactory — это механизм, с помощью которого создаются объекты Connection.
##### Connection
Это долгоживущий объект, который грубо похож на TCP-соединение — после создания он обычно существует в течение всего жизненного цикла приложения до его закрытия. Connection — потокобезопасный и может работать с несколькими потоками одновременно. Объекты Connection позволяют создавать объекты Session.
##### Session
Это дескриптор потока при взаимодействии с брокером. Объекты Session не являются потокобезопасными, что означает, что они не могут быть доступны нескольким потокам одновременно. Session — это основной транзакционный дескриптор, с помощью которого программист может закоммитить и откатить (rollback) операции обмена сообщениями, если он работает в транзакционном режиме. Используя этот объект, вы создаете объекты Message, MessageConsumer и MessageProducer, а также получаете указатели (дескрипторы) на объекты Topic и Queue.
##### MessageProducer/Consumer
MessageProducer - интерфейс позволяющий отправлять сообщение адресату.  
MessageConsumer - интерфейс позволяющий получать сообщения.

Существует два механизма извлечения сообщения:
- Регистрация MessageListener. Это реализованный вами интерфейс обработчика сообщений, который будет последовательно обрабатывать любые сообщения, выдаваемые брокером, используя один поток.
- Опрос (polling) на наличие сообщений с помощью метода receive().
##### Message 
Cамая важная структура, поскольку она переносит ваши данные. Сообщения в JMS состоят из двух частей:
- Метаданные
- Тело сообщения

Сообщение содержит заголовки и свойства. И то, и то может рассматриваться, как элементы мапы. Заголовки — это хорошо известные элементы, определенные спецификацией JMS и доступные напрямую через API, такие как JMSDestination и JMSTimestamp. Свойства — это произвольные фрагменты информации о сообщении, которые задаются для упрощения обработки или маршрутизации сообщений без необходимости считывания самого пейлоада сообщения.

### AMQP
#### Информация
Расширенный протокол очереди сообщений (Advanced Message Queuing Protocol) (ISO / IEC 19464:2014) не следует путать с его предшественником 0.X, который реализован в других системах обмена сообщениями, в частности в RabbitMQ, использующий 0.9.1. AMQP 1.0 является двоичным протоколом общего назначения для обмена сообщениями между двумя узлами. Он не имеет понятия клиентов или брокеров и включает в себя такие функции, как управление потоками, транзакции и различные QoS (не более одного раза, не менее одного раза и точно один раз).
### MQTT (Message queuing telemetry transport)
Легковесный протокол «публикация-подписка» (ISO / IEC 20922:2016), используемый для приложений «Машина-Машина» (M2M) и «Интернет вещей» (IoT).
### Абстрактное взаимодействие через JMS
#### Этапы записи
1. Отправляющий поток вызывает клиентскую библиотеку и маршализирует сообщение в нужный формат. Затем сообщение отправляется брокеру.
2. Брокер записывает сообщение в своё внутреннее хранилище. Как оно устроено – для нас чёрный ящик.
3. После записи сообщения в хранилище персистенс-адаптер должен получить подтверждение того, что сообщение действительно было записано.
4. Как только брокер удостоверится, что сообщение сохранено, он отправит клиенту ответ-подтверждение. После чего, поток клиента, первоначально вызвавший операцию send(), может продолжить свою работу.
![Pasted image 20250610190309.png](../photos/Pasted%20image%2020250610190309.png)
#### Этапы чтения
1. Когда ActiveMQ становится известно о консюмере, он (ActiveMQ) постранично читает (pages) сообщения из хранилища в память для распространения.
2. Затем эти сообщения перенаправляются (dispatched) консюмеру, часто несколькими частями для снижения объема сетевого взаимодействия. Брокер отслеживает, какие сообщения были перенаправлены и какому консьюмеру.
3. В какой-то момент после попадания в буфер предварительной выборки, сообщения вычитываются логикой приложения и брокеру отправляется подтверждение о вычитке.

> Сообщения, полученные консюмером, не обрабатываются сразу приложением, а помещаются в область памяти, известную как буфер предварительной выборки (prefetch buffer). Цель этого буфера состоит в том, чтобы выровнять поток сообщений, чтобы брокер мог выдавать сообщения консюмеру по мере того, как они становятся доступными для отправки, в то время, как консьюмер мог получать их упорядоченно, по одному.

4. Как только брокер принимает подтверждение доставки сообщения, оно удаляется из памяти и из хранилища сообщений (4).
> Упорядочивание времени между обработкой сообщения и его подтверждением настраивается с помощью параметра сессии JMS, называемого acknowledgement mode.

![Pasted image 20250610190605.png](../photos/Pasted%20image%2020250610190605.png)